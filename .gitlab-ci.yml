# git config --global user.name "tydevilish"
# git config --global user.email "meawpain12@gmail.com"

stages:
  - test
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_TAG: "${CI_COMMIT_SHORT_SHA}"
  BACKEND_IMAGE: "${CI_REGISTRY_IMAGE}/backend:${IMAGE_TAG}"
  FRONTEND_IMAGE: "${CI_REGISTRY_IMAGE}/frontend:${IMAGE_TAG}"

  VM1_IP: "192.168.10.20"
  VM1_REGISTRY_PORT: "5005"

  VM2_IP: "192.168.10.30"
  VM2_USER: "root"
  PROJECT_PATH: "/root/myproject"

default:
  interruptible: true

# ==========================================
# STAGE: TEST
# ==========================================
test_backend:
  stage: test
  image: node:20-alpine
  script:
    - cd backend && npm ci && npm run lint --if-present && npm test --if-present
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH != "main"
      changes: ["backend/**"]
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

test_frontend:
  stage: test
  image: node:20-alpine
  script:
    - cd frontend && npm ci && npm run lint --if-present && npm test --if-present
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH != "main"
      changes: ["frontend/**"]
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ==========================================
# STAGE: BUILD
# ==========================================
.build_template:
  stage: build
  image: docker:26
  services:
    - docker:26-dind
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin

build_backend:
  extends: .build_template
  needs: ["test_backend"]
  script:
    - docker build -t "$BACKEND_IMAGE" ./backend
    - docker push "$BACKEND_IMAGE"
    - |
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        docker tag "$BACKEND_IMAGE" "${CI_REGISTRY_IMAGE}/backend:latest"
        docker push "${CI_REGISTRY_IMAGE}/backend:latest"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH != "main"
      changes: ["backend/**"]

build_frontend:
  extends: .build_template
  needs: ["test_frontend"]
  script:
    - docker build -t "$FRONTEND_IMAGE" ./frontend
    - docker push "$FRONTEND_IMAGE"
    - |
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        docker tag "$FRONTEND_IMAGE" "${CI_REGISTRY_IMAGE}/frontend:latest"
        docker push "${CI_REGISTRY_IMAGE}/frontend:latest"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH != "main"
      changes: ["frontend/**"]

# ==========================================
# STAGE: DEPLOY
# ==========================================
deploy_to_vm2:
  stage: deploy
  image: alpine:latest
  needs: ["build_backend", "build_frontend"]
  before_script:
    - apk add --no-cache openssh-client bash rsync

    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - eval "$(ssh-agent -s)"
    - ssh-add ~/.ssh/id_rsa
    - echo -e "Host $VM2_IP\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config

  script:
    - echo "Deploying to VM2 ($VM2_IP)..."

    # สร้าง Folder ปลายทาง
    - ssh $VM2_USER@$VM2_IP "mkdir -p $PROJECT_PATH"

    # ส่งไฟล์ Config
    - rsync -avz docker-compose.prod.yml $VM2_USER@$VM2_IP:$PROJECT_PATH/
    - rsync -avz ./nginx $VM2_USER@$VM2_IP:$PROJECT_PATH/
    - rsync -avz ./mosquitto $VM2_USER@$VM2_IP:$PROJECT_PATH/
    # เพิ่มบรรทัดนี้: ส่งโฟลเดอร์ nodered (ที่มี settings.js) ไปด้วย
    - rsync -avz ./nodered $VM2_USER@$VM2_IP:$PROJECT_PATH/

    # รัน Docker Compose ที่ปลายทาง
    - |
      ssh $VM2_USER@$VM2_IP "
        # Login ไปที่ Registry (VM1)
        echo '$DEPLOY_TOKEN' | docker login -u '$DEPLOY_USER' --password-stdin $VM1_IP:$VM1_REGISTRY_PORT
        
        cd $PROJECT_PATH
        
        # Export Variables
        export IMAGE_TAG=$IMAGE_TAG
        export CI_REGISTRY_IMAGE=$VM1_IP:$VM1_REGISTRY_PORT/$CI_PROJECT_PATH
        
        # Pull & Up
        echo 'Pulling and restarting containers...'
        docker compose -f docker-compose.prod.yml pull
        docker compose -f docker-compose.prod.yml up -d --remove-orphans
        
        # ล้าง Image เก่า
        docker image prune -f
      "

  rules:
    - if: $CI_COMMIT_BRANCH == "main"
